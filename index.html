<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ChatGPT風チャット — 完全版</title>
  <style>
    :root{
      --bg:#071023; --card:#071428; --accent:#7c3aed; --muted:#94a3b8; --user:#0ea5a4;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:Inter, 'Noto Sans JP',sans-serif;
      background:radial-gradient(1200px 600px at 10% 10%, rgba(124,58,237,0.08), transparent),
                 linear-gradient(180deg,#020617 0%, #071023 100%);
      color:#e6eef8;display:flex;align-items:stretch;
    }
    .container{display:grid;grid-template-columns:320px 1fr;gap:0;flex:1;max-width:1200px;margin:auto;width:100%;height:100vh;border-radius:12px;overflow:hidden;box-shadow:0 20px 60px rgba(2,6,23,0.7)}
    /* sidebar */
    .sidebar{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:16px;border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
    .brand{display:flex;align-items:center;gap:10px;margin-bottom:12px}
    .brand h1{font-size:1.05rem;margin:0}
    .controls{display:flex;gap:8px;margin-bottom:12px}
    button{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}
    .conversations{flex:1;overflow:auto;display:flex;flex-direction:column;gap:8px}
    .conv{padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);cursor:pointer;display:flex;align-items:center;justify-content:space-between}
    .conv.active{outline:2px solid rgba(124,58,237,0.12);background:linear-gradient(90deg, rgba(124,58,237,0.04), rgba(255,255,255,0.01))}
    /* main */
    .main{display:flex;flex-direction:column;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .messages{flex:1;padding:18px;overflow:auto;display:flex;flex-direction:column;gap:12px}
    .msg{max-width:78%;padding:12px;border-radius:12px;line-height:1.45;box-shadow:0 6px 18px rgba(2,6,23,0.5)}
    .msg.user{align-self:flex-end;background:linear-gradient(90deg,var(--user),#036b9a);color:#001218;border-bottom-right-radius:4px}
    .msg.assistant{align-self:flex-start;background:linear-gradient(90deg,#0b1220,#071428);border:1px solid rgba(255,255,255,0.03)}
    .meta{padding:10px 16px;border-top:1px solid rgba(255,255,255,0.02);display:flex;align-items:center;gap:12px}
    form{display:flex;gap:8px;padding:14px;border-top:1px solid rgba(255,255,255,0.02);align-items:center}
    textarea{flex:1;min-height:54px;resize:none;padding:10px;border-radius:10px;background:#071028;border:1px solid rgba(255,255,255,0.03);color:#e6eef8}
    .pill{padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);background:rgba(255,255,255,0.01);cursor:pointer}
    .small{font-size:0.9rem;color:var(--muted)}
    .topbar{display:flex;align-items:center;gap:8px}
    .template{display:flex;gap:6px}
    pre{background:#0b1220;padding:10px;border-radius:8px;overflow:auto;position:relative}
    pre .copy{position:absolute;right:8px;top:8px;cursor:pointer;background:rgba(255,255,255,0.02);padding:4px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-size:0.8rem}
    @media(max-width:920px){ .container{grid-template-columns:1fr} .sidebar{display:none} }
    .ripple{position:absolute;border-radius:999px;transform:translate(-50%,-50%);pointer-events:none;opacity:0.35}
    .kbd{background:rgba(255,255,255,0.02);border-radius:6px;padding:4px 6px;font-size:0.78rem;border:1px solid rgba(255,255,255,0.02)}
  </style>
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <div class="brand">
        <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%237c3aed'><path d='M12 2L2 7v5c0 5 4 9 10 10s10-4 10-9V7L12 2z'/></svg>" width="38" height="38" alt="logo">
        <h1>ChatGPT風チャット — 完全版</h1>
      </div>

      <div class="controls">
        <button id="newConv">新規</button>
        <button id="exportConv">エクスポート</button>
        <button id="clearHistory">履歴消去</button>
      </div>

      <div class="small">テンプレート</div>
      <div class="controls template" style="margin-bottom:12px">
        <select id="templateSelect" class="pill">
          <option value="">選択...</option>
          <option value="You are a helpful assistant.">シンプルアシスタント</option>
          <option value="Act as a professional translator from Japanese to English.">翻訳者（和→英）</option>
          <option value="Summarize the following text in bullet points.">要約（箇条書き）</option>
        </select>
        <button id="applyTemplate" class="pill">適用</button>
      </div>

      <div class="small" style="margin-bottom:8px">会話</div>
      <div class="conversations" id="conversations"></div>

      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <button id="themeToggle" class="pill">テーマ切替</button>
        <button id="ttsBtn" class="pill">読み上げ</button>
        <button id="voiceBtn" class="pill">音声入力</button>
      </div>

      <div style="margin-top:10px" class="small">モデル選択</div>
      <select id="modelSelect" class="pill" style="margin-top:6px">
        <option>gpt-4o-mini</option>
        <option>gpt-4o</option>
        <option>gpt-4.1-mini</option>
      </select>

      <div style="margin-top:14px" class="small">APIキー（セッション保存）</div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <input id="apiKeyInput" placeholder="sk-..." style="flex:1;padding:8px;border-radius:8px;background:#061025;border:1px solid rgba(255,255,255,0.03);color:#e6eef8">
      </div>
      <div style="margin-top:8px;font-size:0.8rem;color:var(--muted)">※ キーはページ内セッションに保存されます（閉じると消えます）。</div>
    </aside>

    <main class="main">
      <div class="messages" id="messages"></div>

      <div class="meta">
        <div class="small">モデル: <strong id="modelName">gpt-4o-mini</strong></div>
        <div style="flex:1"></div>
        <div class="small">ショートカット: <span class="kbd">Ctrl+K</span> 新規</div>
      </div>

      <form id="inputForm">
        <textarea id="prompt" placeholder="メッセージを入力（Shift+Enterで改行）"></textarea>
        <button type="button" id="sendBtn" class="pill">送信</button>
        <button type="button" id="continueBtn" class="pill">続きを生成</button>
      </form>
    </main>
  </div>

  <script>
    // --- state ---
    const STORAGE_KEY = 'chat_full_v1';
    let state = {conversations:[], active:null};

    // --- DOM ---
    const convListEl = document.getElementById('conversations');
    const messagesEl = document.getElementById('messages');
    const promptEl = document.getElementById('prompt');
    const newConvBtn = document.getElementById('newConv');
    const clearHistoryBtn = document.getElementById('clearHistory');
    const exportConvBtn = document.getElementById('exportConv');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const modelSelect = document.getElementById('modelSelect');
    const modelName = document.getElementById('modelName');
    const templateSelect = document.getElementById('templateSelect');
    const applyTemplate = document.getElementById('applyTemplate');
    const themeToggle = document.getElementById('themeToggle');
    const ttsBtn = document.getElementById('ttsBtn');
    const voiceBtn = document.getElementById('voiceBtn');
    const sendBtn = document.getElementById('sendBtn');
    const continueBtn = document.getElementById('continueBtn');

    // load/save
    function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
    function loadState(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(raw) state = JSON.parse(raw); }catch(e){console.warn(e);} }

    // UI helpers
    function createConversation(){ const c = {id:Date.now().toString(), title:'無題', messages:[]}; state.conversations.unshift(c); state.active=c.id; saveState(); render(); }
    function selectConversation(id){ state.active=id; saveState(); render(); }

    function renderConversations(){
      convListEl.innerHTML='';
      state.conversations.forEach(c=>{
        const d = document.createElement('div');
        d.className='conv'+(c.id===state.active? ' active':'');
        d.innerHTML = `<div style="flex:1;">${escapeHtml(c.title || '無題')}</div><div class='small' style='opacity:0.6'>${c.messages.length}</div>`;
        d.onclick = ()=>selectConversation(c.id);
        convListEl.appendChild(d);
      });
    }

    function escapeHtml(s){ const div=document.createElement('div'); div.textContent = s; return div.innerHTML; }

    // Markdown render (simple, safe: escape then convert)
    function renderMarkdown(text){
      const escaped = escapeHtml(text);
      // headings
      let t = escaped.replace(/^### (.*$)/gim, '<h3>$1</h3>').replace(/^## (.*$)/gim, '<h2>$1</h2>').replace(/^# (.*$)/gim, '<h1>$1</h1>');
      // code blocks
      t = t.replace(/```([\s\S]*?)```/gim, function(_, code){ return `<pre><code>${code.replace(/</g,'&lt;')}</code></pre>`; });
      // inline code
      t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
      // newlines
      t = t.replace(/\n/g, '<br/>');
      return t;
    }

    function renderMessages(){
      messagesEl.innerHTML=''; const conv = state.conversations.find(c=>c.id===state.active); if(!conv) return;
      conv.messages.forEach((m, idx)=>{
        const d = document.createElement('div'); d.className='msg '+(m.role==='user'?'user':'assistant');
        d.innerHTML = renderMarkdown(m.content||'');
        // add copy button to code blocks
        Array.from(d.querySelectorAll('pre')).forEach(pre=>{
          const btn = document.createElement('button'); btn.textContent='コピー'; btn.className='copy';
          btn.onclick = ()=>{ navigator.clipboard.writeText(pre.innerText).then(()=>{ btn.textContent='コピー済'; setTimeout(()=>btn.textContent='コピー',900); }); };
          pre.appendChild(btn);
        });
        messagesEl.appendChild(d);
      });
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // events
    newConvBtn.addEventListener('click', ()=>createConversation());
    clearHistoryBtn.addEventListener('click', ()=>{ if(confirm('履歴を消しますか？')){ state={conversations:[],active:null}; saveState(); render(); }});
    exportConvBtn.addEventListener('click', ()=>{ const conv = state.conversations.find(c=>c.id===state.active); if(!conv) return; const blob = new Blob([JSON.stringify(conv,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='conversation.json'; a.click(); });
    applyTemplate.addEventListener('click', ()=>{ const t = templateSelect.value; if(!t) return; promptEl.value = t; promptEl.focus(); });

    // theme toggle
    let theme = localStorage.getItem('theme') || 'dark';
    if(theme==='light'){ document.body.style.filter = 'invert(0.04) hue-rotate(10deg)'; }
    themeToggle.addEventListener('click', ()=>{ theme = theme==='dark'? 'light':'dark'; localStorage.setItem('theme', theme); document.body.style.filter = theme==='light'? 'invert(0.04) hue-rotate(10deg)' : 'none'; });

    // TTS
    ttsBtn.addEventListener('click', ()=>{ const conv = state.conversations.find(c=>c.id===state.active); if(!conv) return; const text = conv.messages.map(m=> (m.role==='assistant'? m.content:'' )).join('\n'); if(!text) return alert('読み上げる内容がありません'); speak(text); });
    function speak(text){ if(!('speechSynthesis' in window)) return alert('TTS非対応'); const u = new SpeechSynthesisUtterance(text); u.lang='ja-JP'; speechSynthesis.cancel(); speechSynthesis.speak(u); }

    // Voice input
    let recognition = null;
    if('webkitSpeechRecognition' in window || 'SpeechRecognition' in window){
      const Rec = window.SpeechRecognition || webkitSpeechRecognition;
      recognition = new Rec();
      recognition.lang = 'ja-JP';
      recognition.interimResults = false;
      recognition.onresult = e=>{ promptEl.value = e.results[0][0].transcript; };
      recognition.onerror = ()=>{ /* ignore */ };
    }
    voiceBtn.addEventListener('click', ()=>{ if(!recognition) return alert('音声入力非対応'); try{ recognition.start(); }catch(e){ try{ recognition.stop(); recognition.start(); }catch(e){} } });

    // shortcuts
    document.addEventListener('keydown', e=>{ if(e.ctrlKey && e.key==='k'){ e.preventDefault(); createConversation(); } });

    // API helpers
    function getApiKey(){ return apiKeyInput.value || sessionStorage.getItem('OPENAI_API_KEY'); }
    apiKeyInput.addEventListener('change', ()=>{ sessionStorage.setItem('OPENAI_API_KEY', apiKeyInput.value); });
    modelSelect.addEventListener('change', ()=>{ modelName.textContent = modelSelect.value; });

    // send message (non-streaming, robust)
    async function sendMessage(text){
      if(!text) return;
      let conv = state.conversations.find(c=>c.id===state.active);
      if(!conv) { createConversation(); conv = state.conversations.find(c=>c.id===state.active); }
      conv.messages.push({role:'user', content:text});
      conv.title = text.slice(0,30) + (text.length>30? '…':'');
      saveState(); renderMessages(); promptEl.value='';

      // placeholder assistant
      conv.messages.push({role:'assistant', content:'考えています…'});
      saveState(); renderMessages();

      const apiKey = getApiKey();
      if(!apiKey){
        conv.messages[conv.messages.length-1].content = 'エラー: APIキーが設定されていません。サイドバーに入力してください。';
        saveState(); renderMessages(); return;
      }

      const model = modelSelect.value || 'gpt-4o-mini';
      const payload = {
        model,
        messages: conv.messages.map(m=>({role:m.role, content:m.content})),
        temperature: 0.7,
        max_tokens: 1000
      };

      try{
        // Fallback non-streaming request
        const res = await fetch('https://api.openai.com/v1/chat/completions', {
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer '+apiKey },
          body: JSON.stringify(payload)
        });
        if(!res.ok){
          const t = await res.text();
          throw new Error('APIエラー '+res.status+': '+t);
        }
        const data = await res.json();
        const assistantText = data.choices?.[0]?.message?.content || '';
        conv.messages[conv.messages.length-1].content = assistantText;
        // auto title if first exchange
        if(conv.messages.length===2) autoTitle(apiKey, conv);
        saveState(); renderMessages();
      }catch(err){
        conv.messages[conv.messages.length-1].content = 'エラー: ' + (err.message || String(err));
        saveState(); renderMessages();
      }
    }

    sendBtn.addEventListener('click', ()=>{ const t = promptEl.value.trim(); if(!t) return; sendMessage(t); rippleAt(window.event?.clientX || 0, window.event?.clientY || 0); });
    continueBtn.addEventListener('click', ()=>{ const conv = state.conversations.find(c=>c.id===state.active); if(!conv) return; sendMessage('続きの出力をしてください。'); });

    // auto title helper
    async function autoTitle(apiKey, conv){
      try{
        const res = await fetch('https://api.openai.com/v1/chat/completions', {
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer '+apiKey },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [{role:'user', content: '次の文章に短いタイトルをつけてください:\n' + conv.messages[0].content}],
            max_tokens: 30
          })
        });
        if(!res.ok) return;
        const d = await res.json();
        const t = d.choices?.[0]?.message?.content;
        if(t){ conv.title = t.replace(/\n/g,' ').slice(0,40); saveState(); renderConversations(); }
      }catch(e){}
    }

    // Enter to send (Shift+Enter = newline)
    promptEl.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendBtn.click(); } });

    // ripple effect on send
    function rippleAt(x,y){
      const el = document.createElement('div'); el.className='ripple';
      el.style.left = x+'px'; el.style.top = y+'px';
      el.style.width='14px'; el.style.height='14px';
      el.style.background='radial-gradient(circle,rgb(124 58 237) 0%, rgba(124,58,237,0.2) 40%, transparent 60%)';
      document.body.appendChild(el); setTimeout(()=>el.remove(),700);
    }

    // init
    loadState(); if(!state.conversations.length) createConversation();
    render();

    function render(){ renderConversations(); renderMessages(); modelName.textContent = modelSelect.value; }

    // Security note already: messages are escaped before injecting HTML (renderMarkdown uses escapeHtml).
    // Save API key to sessionStorage only when changed
    apiKeyInput.addEventListener('blur', ()=>{ if(apiKeyInput.value) sessionStorage.setItem('OPENAI_API_KEY', apiKeyInput.value); });

    // Final helper: If user wants streaming you'll need to use server-side streaming proxy or SSE parsing.
    // (This client uses a simple non-stream request for compatibility.)

    // End of script
  </script>
</body>
</html>
